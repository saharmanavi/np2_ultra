import os
import json
import numpy as np
import shutil


def fix_spike_times(spike_times_file_path, timestamps_file, probe_data_dir):
    spike_times = np.load(spike_times_file_path)
    if 'spike_times_old.npy' not in os.listdir(probe_data_dir):
        shutil.copy(spike_times_file_path, os.path.join(os.path.dirname(spike_times_file_path), 'spike_times_old.npy'))
        t0 = np.load(timestamps_file)[0]
        spike_times = spike_times + t0
        np.save(spike_times_file_path, spike_times)
    spike_times_old = np.load(os.path.join(probe_data_dir, 'spike_times_old.npy'))
    return spike_times, spike_times_old

def signaltonoise(a, axis=0, ddof=0):
    '''
    Created on Sat Sep 12 15:52:39 2020
    author: svc_ccg
    '''
    a = np.asanyarray(a)
    m = a.mean(axis)
    sd = a.std(axis=axis, ddof=ddof)
    return np.where(sd == 0, 0, m/sd)

def bootstrap_resample(X, n=None):
    """ Bootstrap resample an array.
    Sample with replacement.
    From analysis/sampling.py.
    Parameters
    ----------
    X : array_like
      data to resample
    n : int, optional
      length of resampled array, equal to len(X) if n==None
    Results
    -------
    returns X_resamples

    author: svc_ccg
    """
    if n == None:
        n = len(X)

    resample_i = np.floor(np.random.rand(n)*len(X)).astype(int)
    X_resample = X[resample_i]
    return X_resample

def getPSTH(spikes,startTimes,windowDur,binSize=0.01,avg=True):
    '''
    Created on Sat Sep 12 15:52:39 2020
    author: svc_ccg
    '''
    bins = np.arange(0,windowDur+binSize,binSize)
    counts = np.zeros((len(startTimes),bins.size-1))
    for i,start in enumerate(startTimes):
        counts[i] = np.histogram(spikes[(spikes>=start) & (spikes<=start+windowDur)]-start,bins)[0]
    if avg:
        counts = counts.mean(axis=0)
    counts /= binSize
    t = bins[:-1]
    return counts,t

def get_sync_line_data(syncDataset, line_label=None, channel=None):
    ''' Get rising and falling edge times for a particular line from the sync h5 file

        Parameters
        ----------
        dataset: sync file dataset generated by sync.Dataset
        line_label: string specifying which line to read, if that line was labelled during acquisition
        channel: integer specifying which channel to read in line wasn't labelled

        Returns
        ----------
        rising: npy array with rising edge times for specified line
        falling: falling edge times
    '''
    if isinstance(line_label, str):
        try:
            channel = syncDataset.line_labels.index(line_label)
        except:
            print('Invalid line label')
            return
    elif channel is None:
        print('Must specify either line label or channel id')
        return

    sample_freq = syncDataset.meta_data['ni_daq']['counter_output_freq']
    rising = syncDataset.get_rising_edges(channel)/sample_freq
    falling = syncDataset.get_falling_edges(channel)/sample_freq

    return rising, falling

def get_probe_spatial_layout(probe_type):
    """gets values for:
        probeX/probeY: range of X and Y values of probe as numpy arrays
        probeRows/probeCols: values of number of probe rows and columns as ints

        probe_type: str ('ultra', '1.0')
        """
    if probe_type=='1.0':
        probeRows = 96
        probeCols = 4

        x_spacing = 16
        x_start = 11
        probeX = np.arange(x_start,x_spacing*probeCols, x_spacing)

        y_spacing = 20
        n_row = probeRows*2
        y_start = 20
        probeY = np.arange(y_start, y_spacing*n_row+1, y_spacing)

    elif probe_type=='ultra':
        probeRows = 48
        probeCols = 8
        channelSpacing = 6 # microns
        probeX = np.arange(probeCols)*channelSpacing
        probeY = np.arange(probeRows)*channelSpacing

    else:
        print("Probe type was not understood. Please specify 1.0 or ultra.")

    return probeRows, probeCols, probeX, probeY

def get_channel_positions(data_dir):
    """channel_pos: numpy array of channel positions"""
    channel_pos_file =  os.path.join(data_dir, "channel_positions.npy")
    channel_pos = np.load(channel_pos_file)
    return channel_pos
